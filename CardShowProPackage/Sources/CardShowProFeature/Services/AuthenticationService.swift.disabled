import Foundation
import AuthenticationServices
import SwiftData
import Supabase

/// Manages user authentication via Supabase (Sign in with Apple + Email/Password)
@MainActor
@Observable
final class AuthenticationService: NSObject {
    // MARK: - Published State

    /// Current authenticated user (nil if not signed in)
    private(set) var currentUser: User?

    /// Current authentication state
    private(set) var authState: AuthState = .unauthenticated

    /// Last authentication error
    private(set) var lastError: AuthError?

    // MARK: - Dependencies

    private let supabase: SupabaseClient
    private let modelContext: ModelContext
    private let keychain = KeychainManager()

    // MARK: - Constants

    private let userIdKey = "current_user_id"
    private let sessionKey = "supabase_session"

    // MARK: - Initialization

    init(supabase: SupabaseClient, modelContext: ModelContext) {
        self.supabase = supabase
        self.modelContext = modelContext
        super.init()

        // Listen for auth state changes from Supabase
        Task {
            await listenForAuthChanges()
        }
    }

    // MARK: - Authentication State

    /// Check if user is currently authenticated
    var isAuthenticated: Bool {
        authState == .authenticated
    }

    // MARK: - Sign in with Apple

    /// Initiate Sign in with Apple flow
    func signInWithApple() async throws {
        authState = .loading

        let provider = ASAuthorizationAppleIDProvider()
        let request = provider.createRequest()
        request.requestedScopes = [.email, .fullName]

        do {
            let authorization = try await performAppleSignIn(request: request)

            guard let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential else {
                throw AuthError.invalidCredential
            }

            // Get identity token
            guard let identityTokenData = appleIDCredential.identityToken,
                  let identityToken = String(data: identityTokenData, encoding: .utf8) else {
                throw AuthError.missingToken
            }

            // Sign in to Supabase with Apple token
            let session = try await supabase.auth.signInWithIdToken(
                credentials: .init(provider: .apple, idToken: identityToken)
            )

            // Create or update user
            let user = try await createOrUpdateUser(
                supabaseId: session.user.id.uuidString,
                email: appleIDCredential.email ?? session.user.email,
                displayName: appleIDCredential.fullName?.formatted(),
                appleUserId: appleIDCredential.user
            )

            // Save session
            try await saveSession(session)

            currentUser = user
            authState = .authenticated

        } catch {
            authState = .error
            lastError = .signInFailed(error.localizedDescription)
            throw lastError!
        }
    }

    // MARK: - Email/Password Authentication

    /// Sign up with email and password
    func signUp(email: String, password: String, displayName: String) async throws {
        authState = .loading

        do {
            // Validate input
            try validateEmail(email)
            try validatePassword(password)

            // Sign up with Supabase
            let session = try await supabase.auth.signUp(
                email: email,
                password: password
            )

            // Create user
            let user = try await createOrUpdateUser(
                supabaseId: session.user.id.uuidString,
                email: email,
                displayName: displayName
            )

            // Save session
            try await saveSession(session)

            currentUser = user
            authState = .authenticated

        } catch {
            authState = .error
            lastError = .signUpFailed(error.localizedDescription)
            throw lastError!
        }
    }

    /// Sign in with email and password
    func signIn(email: String, password: String) async throws {
        authState = .loading

        do {
            // Validate input
            try validateEmail(email)

            // Sign in with Supabase
            let session = try await supabase.auth.signIn(
                email: email,
                password: password
            )

            // Get or create user
            let user = try await createOrUpdateUser(
                supabaseId: session.user.id.uuidString,
                email: email
            )

            // Save session
            try await saveSession(session)

            // Update last login
            user.lastLoginAt = Date()
            try modelContext.save()

            currentUser = user
            authState = .authenticated

        } catch {
            authState = .error
            lastError = .signInFailed(error.localizedDescription)
            throw lastError!
        }
    }

    // MARK: - Session Management

    /// Restore session from stored credentials
    func restoreSession() async throws {
        authState = .loading

        do {
            // Try to retrieve saved session
            guard let sessionData = try? await keychain.retrieve(key: sessionKey),
                  let session = try? JSONDecoder().decode(Session.self, from: sessionData.data(using: .utf8)!) else {
                authState = .unauthenticated
                return
            }

            // Restore session in Supabase
            try await supabase.auth.setSession(accessToken: session.accessToken, refreshToken: session.refreshToken)

            // Get user
            guard let userId = try? await keychain.retrieve(key: userIdKey) else {
                authState = .unauthenticated
                return
            }

            // Fetch user from database
            let descriptor = FetchDescriptor<User>(
                predicate: #Predicate { $0.id.uuidString == userId }
            )
            let users = try modelContext.fetch(descriptor)

            if let user = users.first {
                currentUser = user
                authState = .authenticated
            } else {
                authState = .unauthenticated
            }

        } catch {
            authState = .error
            lastError = .sessionRestoreFailed
            throw lastError!
        }
    }

    /// Sign out current user
    func signOut() async throws {
        do {
            // Sign out from Supabase
            try await supabase.auth.signOut()

            // Clear stored session
            try await keychain.delete(key: sessionKey)
            try await keychain.delete(key: userIdKey)

            currentUser = nil
            authState = .unauthenticated

        } catch {
            lastError = .signOutFailed
            throw lastError!
        }
    }

    /// Delete user account permanently
    func deleteAccount() async throws {
        guard let user = currentUser else {
            throw AuthError.notAuthenticated
        }

        do {
            // Delete from Supabase
            // Note: This requires a server-side function as Supabase doesn't expose delete user in client SDK
            // For now, we'll just sign out and mark for deletion

            // Delete local user data
            modelContext.delete(user)
            try modelContext.save()

            // Sign out
            try await signOut()

        } catch {
            lastError = .accountDeletionFailed
            throw lastError!
        }
    }

    // MARK: - Password Management

    /// Send password reset email
    func resetPassword(email: String) async throws {
        do {
            try validateEmail(email)
            try await supabase.auth.resetPasswordForEmail(email)
        } catch {
            lastError = .passwordResetFailed
            throw lastError!
        }
    }

    /// Update password for current user
    func updatePassword(newPassword: String) async throws {
        guard currentUser != nil else {
            throw AuthError.notAuthenticated
        }

        do {
            try validatePassword(newPassword)
            try await supabase.auth.update(user: .init(password: newPassword))
        } catch {
            lastError = .passwordUpdateFailed
            throw lastError!
        }
    }

    // MARK: - Private Helpers

    private func createOrUpdateUser(
        supabaseId: String,
        email: String?,
        displayName: String? = nil,
        appleUserId: String? = nil
    ) async throws -> User {
        // Try to find existing user
        let descriptor = FetchDescriptor<User>(
            predicate: #Predicate { $0.supabaseId == supabaseId }
        )
        let existingUsers = try modelContext.fetch(descriptor)

        if let existingUser = existingUsers.first {
            // Update existing user
            if let email = email { existingUser.email = email }
            if let displayName = displayName { existingUser.displayName = displayName }
            if let appleUserId = appleUserId { existingUser.appleUserId = appleUserId }
            existingUser.lastLoginAt = Date()
            try modelContext.save()
            return existingUser
        } else {
            // Create new user
            let user = User(
                email: email,
                displayName: displayName,
                appleUserId: appleUserId,
                supabaseId: supabaseId
            )
            modelContext.insert(user)
            try modelContext.save()
            return user
        }
    }

    private func saveSession(_ session: Session) async throws {
        // Save session to Keychain
        let sessionData = try JSONEncoder().encode(session)
        let sessionString = String(data: sessionData, encoding: .utf8)!
        try await keychain.save(key: sessionKey, value: sessionString)

        // Save user ID
        if let user = currentUser {
            try await keychain.save(key: userIdKey, value: user.id.uuidString)
        }
    }

    private func listenForAuthChanges() async {
        for await state in supabase.auth.authStateChanges {
            switch state.event {
            case .signedIn:
                authState = .authenticated
            case .signedOut:
                authState = .unauthenticated
                currentUser = nil
            case .userUpdated:
                // Refresh user data
                break
            case .passwordRecovery:
                break
            case .tokenRefreshed:
                // Session refreshed automatically
                break
            }
        }
    }

    private func performAppleSignIn(request: ASAuthorizationAppleIDRequest) async throws -> ASAuthorization {
        try await withCheckedThrowingContinuation { continuation in
            let controller = ASAuthorizationController(authorizationRequests: [request])
            controller.delegate = AppleSignInDelegate(continuation: continuation)
            controller.performRequests()
        }
    }

    // MARK: - Validation

    private func validateEmail(_ email: String) throws {
        guard !email.isEmpty else {
            throw AuthError.invalidEmail
        }

        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let emailPredicate = NSPredicate(format: "SELF MATCHES %@", emailRegex)

        guard emailPredicate.evaluate(with: email) else {
            throw AuthError.invalidEmail
        }
    }

    private func validatePassword(_ password: String) throws {
        guard password.count >= 8 else {
            throw AuthError.weakPassword
        }

        // Could add more password validation here
    }
}

// MARK: - Auth State

enum AuthState: Sendable {
    case unauthenticated
    case loading
    case authenticated
    case error
}

// MARK: - Auth Errors

enum AuthError: Error, LocalizedError {
    case invalidCredential
    case missingToken
    case invalidEmail
    case weakPassword
    case signInFailed(String)
    case signUpFailed(String)
    case signOutFailed
    case sessionRestoreFailed
    case accountDeletionFailed
    case passwordResetFailed
    case passwordUpdateFailed
    case notAuthenticated

    var errorDescription: String? {
        switch self {
        case .invalidCredential:
            return "Invalid credentials provided"
        case .missingToken:
            return "Authentication token is missing"
        case .invalidEmail:
            return "Please enter a valid email address"
        case .weakPassword:
            return "Password must be at least 8 characters"
        case .signInFailed(let message):
            return "Sign in failed: \(message)"
        case .signUpFailed(let message):
            return "Sign up failed: \(message)"
        case .signOutFailed:
            return "Failed to sign out. Please try again."
        case .sessionRestoreFailed:
            return "Could not restore your session. Please sign in again."
        case .accountDeletionFailed:
            return "Failed to delete account. Please contact support."
        case .passwordResetFailed:
            return "Failed to send password reset email"
        case .passwordUpdateFailed:
            return "Failed to update password"
        case .notAuthenticated:
            return "You must be signed in to perform this action"
        }
    }
}

// MARK: - Apple Sign In Delegate

private class AppleSignInDelegate: NSObject, ASAuthorizationControllerDelegate {
    private let continuation: CheckedContinuation<ASAuthorization, Error>

    init(continuation: CheckedContinuation<ASAuthorization, Error>) {
        self.continuation = continuation
    }

    func authorizationController(
        controller: ASAuthorizationController,
        didCompleteWithAuthorization authorization: ASAuthorization
    ) {
        continuation.resume(returning: authorization)
    }

    func authorizationController(
        controller: ASAuthorizationController,
        didCompleteWithError error: Error
    ) {
        continuation.resume(throwing: error)
    }
}

// MARK: - Keychain Manager

actor KeychainManager {
    enum KeychainError: Error {
        case itemNotFound
        case duplicateItem
        case unexpectedData
        case unhandledError(status: OSStatus)
    }

    func save(key: String, value: String) throws {
        guard let data = value.data(using: .utf8) else {
            throw KeychainError.unexpectedData
        }

        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key,
            kSecValueData as String: data,
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlocked
        ]

        let status = SecItemAdd(query as CFDictionary, nil)

        if status == errSecDuplicateItem {
            // Update existing item
            let attributesToUpdate: [String: Any] = [kSecValueData as String: data]
            let updateStatus = SecItemUpdate(query as CFDictionary, attributesToUpdate as CFDictionary)

            guard updateStatus == errSecSuccess else {
                throw KeychainError.unhandledError(status: updateStatus)
            }
        } else {
            guard status == errSecSuccess else {
                throw KeychainError.unhandledError(status: status)
            }
        }
    }

    func retrieve(key: String) throws -> String {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]

        var item: CFTypeRef?
        let status = SecItemCopyMatching(query as CFDictionary, &item)

        guard status != errSecItemNotFound else {
            throw KeychainError.itemNotFound
        }

        guard status == errSecSuccess else {
            throw KeychainError.unhandledError(status: status)
        }

        guard let data = item as? Data,
              let value = String(data: data, encoding: .utf8) else {
            throw KeychainError.unexpectedData
        }

        return value
    }

    func delete(key: String) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key
        ]

        let status = SecItemDelete(query as CFDictionary)

        guard status == errSecSuccess || status == errSecItemNotFound else {
            throw KeychainError.unhandledError(status: status)
        }
    }
}
